oryonatan
yulishap


Files:
Directory: actions 
Action.java 			- the actions interface
ActionsEnum.java		- enum which holds all the action class types
CopyAction.java			- an action that copies files
ExecAction.java			- an action that sets execution permissions
LastModAction.java		- an action that sets last modification date
PrintDataAction.java	- an action that prints all the attributes of the filtered files
PrintNameAction.java	- an action that prints the name of the filtered files
WriteAction.java 		- an action that sets write permissions

Directory: Filters
AfterFilter.java		-filter files modified after a given date
BeforeFilter.java		-filter files modified before a given date
DateFilter.java			-superclass for filters that gets date as a parameter
DoubleFilter.java		-superclass for filters that gets a double as parameter
EndsWithFilter.java		-filter files that ends with a given suffix
ExecFilter.java			-filter files based on execution permissions
FileFilterBox.java		-a collection of filters representing the filters in a given FILTER subsection
								in the input file
FileSizeFilter.java		-superclass for a double filter that gets a file size
FilterLine.java			-represents a line in the FILTER subsection
FiltersEnum.java		-enum which holds all the filter  class types
FolderFilter.java		-filter only folders
GreaterThanFilter.java- filter files bigger than a given file size
HiddenFilter.java		-filter files based on visibility.
NameFilter.java			-filter files by name
NegatableFilter.java	-superclass for all the filters that require negateability
SmallerThanFilter.java- filter files smaller than a given file size
StartsWithFilter.java	-filter files that starts with a given prefix
WriteableFilter.java	-filter files by writing permissions.
YesNoFilter.java		-superclass for filters that gets YES or NO as a parameter

Directory: orders
AbsComparator.java	- a comparator that orders by full file path name
FileComparator.java	- a comparator that orders by file name
ModComparator.java	- a comparator that orders by modification date
OrdersEnum.java		- enum which holds all the order class types
SizeComparator.java - a comparator that orders by file size

Directory: parser
ActionParser.java 	- a parser which parses an "ACTION" subsection and generates
							actions accordingly
Block.java			- a block is an object that represents a piece of the input file , 
							it is generated by the parsers and run , by the MyFileScript main.
FilterParser.java 	- a parser which parses an "FILTER" subsection and generates
							filters accordingly
OrderParser.java	- a parser which parses an "ORDER" subsection and generates
							orders accordingly
Parser.java			- a parser which parses the command file 

Directory Exceptions:
AbsComperatorIOError.java					-Abs comparator failed to call the GetCannonicalPath 
ArgsNumException.java						-Wrong number of args passed to an object
BadOrderException.java						-Bad order specified
BadParamException.java						-General superclass for bad parameters in the input
BlockException.java							-General error in the Block object
PermissionsException.java					-PermissionError when performing an IO action
StringCaseException.java					-String case is wrong
Directory Exceptions\ActionExceptions:	
ActionCopyAbsPathException.java				-attempt to copy a file to a directory starting with / 
ActionException.java						-General action exception
ActionParamSizeException.java				-Wrong number of parameters in an action.
Directory Exceptions\FilterExceptions:
DateFilterParseException.java				-Date failed to parse in a date based filter
DoubleFilterParseFailedException.java		-Double failed to parse in a double based filter
YesNoFilterYesNoStringException.java		-The string "YES" or "NO" was not specified in the correct way/location
Directory Exceptions\ParserExceptions:
IlegalFilterException.java					-Trying to generate a non existent or wrong filter
IllegalOrderException.java					-Trying to generate a non existent or wrong order
ParserException.java						-General parser exception

Design :

Abstract:
This is a summary of the code behavior :
1. The parser is parsing the text to an list of strings .
2.The parser repeatedly calls the makeblock method , which calls the Action/Filter/Order parsers
to generate a list of Block objects, returning it to the main().
3.The main() method , is calling the run() method of each object.
4.The run() method , lists all files which where filtered , puts the in a TreeSet ordered with the
order object, and the executes the action on the with the given order.
In case of exception on the way - the main() method will catch the exception and err to the screen.

Parsing : 
The parser parses the command file in couple of steps:
1.	It reads the command file
2.  It divides the file into "blocks" ( not to be confused with the Object Block) 
	of strings which hold three subsections (Filter,Action,Order)
3.  It retrieves the comments from the blocks so for each block we will have
	a comments array
4.	for each block it divides it to subsections of filters,actions and order 
	and calls the matching parsers which should know how to parse each subsection.
	There is ActionParser for parsing actions, FilterParser for parsing filters, 
	OrderParser for parsing orders.
5.  Each parser has a factory method which generates the matching object by use of an ENUM
	(see implementation of ENUMs)
6.  The parser compiles the different objects to arrayLists (in actions) or FileFilterBox (in filters)
	and one comparator (in order) and generates a Block object which holds all of them (see implementation of
	Block)

Filters :
The filters implements the Java.io.File.FileFilter interface , implementing just a single method :
accept(File). 
The NegatableFilter superclass , implements the Negate() function , which sets the local 
boolean negative to true/false each time it is called , the value is then XORed with the return
value of each filter accept(File) method practically reversing the behavior of the specific filter.
Filters structure : 
While all filters (except FolderFilter) extends the NegatableFilter superclass , still there are few 
common characteristics of various filters : 
*Filter which accepts a double number (DoubleFilter)
*Filters which accepts a date (DateFilter)
*Filters which accept a YES or NO as string (YesNoFilter)
in those cases , the specific filter, extends the parent filter , which provides argument
parsing functionality. 
Some filters accept a string and don't need such treatment.

FolderFilter , is a filter that allows all the folders to pass, it is used once in the
recursive directory enumeration.

The Block(see below) object don't hold all the filters together, instead - we generate a 
FilterBox object which holds all the filters as FilterLines object, thus representing the 
filters in an input file in a very similar way to the way they are written.

The FilterLine objects implements accept() method , with the following rule :
If any of the filters in the line is accepting the file - return true, this is due to the
requirement of filters in the same line to work as an OR. 
The FilterBox also implements the accept() method ,however the way it works 
is by requiring all the filters to return true , essentially providing an AND rule.

Action structure:
All the actions implement the action interface which holds two methods - the ctor and exec.
The ctor in the interface checks if the action received the amount of parameters it supposed to receive.
The exec method executes the action.
The ctor in the actions receives all the needed parameters from the commands file, 
and the source directory as an array of strings. 

Order structure:
All the orders are comparators which compare between files, so they all implement
the compare method.
Except the abs order all the other orders extend the abs comparator
so in a situation when two files are considered equal, the order could call the
abs's compare method.

Exceptions : 
There are specific exceptions for various situations that might
occur during runtime, some exceptions are grouped under
some similarities.
A specific notion should be given the BadParamExcpetion type,
a superclass that most of the exceptions are inheriting from,
this exception in general is an exception that is caused by
user giving the program bad parameters, as this is the most common
cause of error.

Implementation Issues:
ENUMs
In order to generate the different filters/actions/orders dynamically in run time, 
we use Enum whose keys are the different filters/actions/orders name ( as they should appear 
in the command file ) and the values are the matching class types of the filters/actions/orders 
classes. We then use reflection (the method getConstructor) in order to get its ctor, and by 
the ctor we generate the object through the newInstance() method.

It should be noticed that all the filters get one parameter so the reflection of the ctor
is done by getting the ctor which receives a string.
On the other hand, the actions can have one param or none from the command file in addition to
the source dir which should be passed to them. So the solution was to make the action ctor 
get an array of strings, and in runtime pass an array to the ctor which may hold a parameter
if needed, and if not, will hold only the source dir.
The orders ctor however , don't get any parameters, so we can use the method newInstance without 
any reflection of the ctor.

Block
We use an object of type Block which holds an "executable" logic unit which holds FileFilterBox
of filters which is essentially an arrayList of filters, arraylist of action, a comparator as an
order and an array of strings as comments. The parser's job is to parse the command file and to
generate an arraylist of such blocks. All is left for the MyFileScript to do is to run all the blocks.
The block also implements a recursiveDir method.

How do we provide extensibility ?
Adding a filter/action/order is a fairly simple task , one should only write his class
for the specific order /filter/action, and add a line with the classtype in the according enum.
The reflection mechanism used by the parsers should do the rest of the work.
